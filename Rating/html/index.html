<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
  <head>
    <title>rating [PsychoPy]</title>
    <meta charset="UTF-8">
    <link href="js/vendors//jquery-ui-1.11.4.base/jquery-ui.min.css" rel="stylesheet">

    <style>
        /* project and resource dialogs */
        label, input { display:block; padding-bottom: .5em; }
        input.text { margin-bottom:1em; width:95%; padding: .5em; }
        fieldset { padding:0; border:0; margin-top:25px; }

        /* don't display close button in the top right corner of the box */
        .no-close .ui-dialog-titlebar-close { display: none; }
    </style>
  </head>

  <body>

    <!-- dialog place holder -->
    <div id="dialogDiv"/>

    <script type="text/javascript" src="js/vendors/seedrandom.min.js"></script>
    <script type="text/javascript" src="js/vendors/Math2.js"></script>
    <script type="text/javascript" src="js/vendors/jquery-2.2.0.min.js"></script>
    <script type="text/javascript" src="js/vendors/jquery-ui-1.11.4.base/jquery-ui.min.js"></script>
    <script type="text/javascript" src="js/vendors/jquery.blockUI.js" ></script>
    <script type="text/javascript" src="js/vendors/stats.min.js"></script>
    <script type="text/javascript" src="js/vendors/pixi.min.js"></script>
    <script type="text/javascript" src="js/vendors/papaparse.min.js"></script>
    <script type="text/javascript" src="js/vendors/preloadjs-0.6.2.min.js"></script>

    <script type="text/javascript" src="js/psychojs/main.js"></script>
    <script type="text/javascript" src="js/psychojs/core.js"></script>
    <script type="text/javascript" src="js/psychojs/data.js"></script>
    <script type="text/javascript" src="js/psychojs/events.js"></script>
    <script type="text/javascript" src="js/psychojs/gui.js"></script>
    <script type="text/javascript" src="js/psychojs/util.js"></script>
    <script type="text/javascript" src="js/psychojs/scheduler.js"></script>
    <script type="text/javascript" src="js/psychojs/visual.js"></script>
    <script type="text/javascript" src="js/psychojs/io.js"></script>
    <script type="text/javascript" src="js/psychojs/jamdb.js"></script>
    <script type="text/javascript" src="js/psychojs/colors.js"></script>
    <script type="text/javascript" src="js/psychojs/logging.js"></script>

    <script type='text/javascript'>
      // wait until document is ready:
      $(document).ready(function() {
        psychoJS.debug = true; //false;
        
        function setupExperiment() {
        
          // An ExperimentHandler isn't essential but helps with data saving
          thisExp = new psychoJS.data.ExperimentHandler({
              name: 'rating',
              version: '',
              extraInfo: expInfo,
              runtimeInfo: undefined,  // not yet supported by psychoJS
              originPath: undefined,  //not yet supported by psychoJS
              savePickle: true,       // not yet supported by psychoJS
              saveWideText: true,
              saveTo: 'EXPERIMENT_SERVER',
              /*dataFileName=filename*/});
        
          // setup resource manager:
          psychoJS.resourceManager.set({
                                win:win, downloadFrom:'EXPERIMENT_SERVER', projectId:undefined,
                                projectStatus:'PUBLIC', clock:new psychoJS.core.Clock()
                                });
        
          endExpNow = false; // flag for 'escape' or other condition => quit the exp
        
          // logging:
          psychoJS.logging.console.setLevel(psychoJS.logging.EXP);
          psychoJS.logging.server.set({'level':psychoJS.logging.EXP, 'saveTo':'EXPERIMENT_SERVER', 'experimentInfo': expInfo});
        
          return psychoJS.NEXT;
        }
        
        function updateInfo() {
          expInfo['date'] = psychoJS.data.getDateStr();  // add a simple timestamp
          expInfo['expName'] = expName;
        
          // store frame rate of monitor if we can measure it successfully
          expInfo['frameRate'] = win.getActualFrameRate();
          if (expInfo['frameRate'] != undefined) {
              frameDur = 1.0/Math.round(expInfo['frameRate']);
          }
          else {
              frameDur = 1.0/60.0; // couldn't get a reliable measure so guess
          }
        
          return psychoJS.NEXT;
        }
        
        function setupWin() {
          // Start Code - component code to be run before the window creation
          // Setup the Window
          win = new psychoJS.visual.Window({size:[1000, 600],
              fullscr:false, screen:1.0,
              allowGUI:false, allowStencil:false,
              monitor:'testMonitor',
              color:[0,0,0], colorSpace:'rgb',
              blendMode:'avg',
              units:'use prefs'
              });
          return psychoJS.NEXT;
        }
        
        function experimentInit() {
          
          // Initialize components for Routine "practice_introduction"
          practice_introductionClock = new psychoJS.core.Clock();
          instruction1 = new psychoJS.visual.TextStim({win : win, name : 'instruction1',
              text : 'Welcome.\n\nListen carefully to the sounds that you will hear \nand then rate on a scale from 1 to 7.\n\nTry to respond as quickly and as accurately as possible.\n\nPress spacebar to begin.',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : 2, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          
          // Initialize components for Routine "trial1"
          trial1Clock = new psychoJS.core.Clock();
          word1 = new psychoJS.visual.TextStim({win : win, name : 'word1',
              text : 'default text',
              font : 'Arial',
              pos : [0, 0.3], height : 0.3, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          trial_number1 = new psychoJS.visual.TextStim({win : win, name : 'trial_number1',
              text : 'default text',
              font : 'Arial',
              pos : [0.5, -0.8], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : -1.0 
          });
          scale_msg1 = new psychoJS.visual.TextStim({win : win, name : 'scale_msg1',
              text : 'least accurate(1)            most accurate(7)',
              font : 'Arial',
              pos : [0, -0.2], height : 0.1, wrapWidth : 2, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : -3.0 
          });
          
          // Initialize components for Routine "main_instruction"
          main_instructionClock = new psychoJS.core.Clock();
          instruction2 = new psychoJS.visual.TextStim({win : win, name : 'instruction2',
              text : 'OK, ready to start the main experiment?\n\nListen and rate on a scale from 1 to 7.\nTry to respond as quickly and as accurately as possible.\n\nPress spacebar to continue.',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : 2, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          
          // Initialize components for Routine "trial2"
          trial2Clock = new psychoJS.core.Clock();
          word2 = new psychoJS.visual.TextStim({win : win, name : 'word2',
              text : 'default text',
              font : 'Arial',
              pos : [0, 0.2], height : 0.3, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          trial_number2 = new psychoJS.visual.TextStim({win : win, name : 'trial_number2',
              text : 'default text',
              font : 'Arial',
              pos : [0.5, -0.8], height : 0.1, wrapWidth : undefined, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : -1.0 
          });
          scale_msg2 = new psychoJS.visual.TextStim({win : win, name : 'scale_msg2',
              text : 'least accurate(1)            most accurate(7)',
              font : 'Arial',
              pos : [0, -0.2], height : 0.1, wrapWidth : 2, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : -3.0 
          });
          
          // Initialize components for Routine "the_end"
          the_endClock = new psychoJS.core.Clock();
          text = new psychoJS.visual.TextStim({win : win, name : 'text',
              text : 'Thank you for participating in this experiment.',
              font : 'Arial',
              pos : [0, 0], height : 0.1, wrapWidth : 2, ori:0, 
              color : 'white', colorSpace:'rgb', opacity : 1,
              depth : 0.0 
          });
          
          // Create some handy timers
          globalClock = new psychoJS.core.Clock();  // to track the time since experiment started
          routineTimer = new psychoJS.core.CountdownTimer();  // to track time remaining of each (non-slip) routine
          
          return psychoJS.NEXT;
        }
        
        function trial2RoutineBegin() {
          //------Prepare to start Routine 'trial2'-------
          t = 0;
          trial2Clock.reset(); // clock
          frameN = -1;
          // update component parameters for each repeat
          word2.setText(word);
          trial_number2.setText(str(main_trial.thisN+1) + " / " + str(main_trial.nTotal) );
          // keep track of which components have finished
          trial2Components = [];
          trial2Components.push(word2);
          trial2Components.push(trial_number2);
          trial2Components.push(scale_msg2);
          for(var i = 0; i < trial2Components.length; ++i) {
            thisComponent = trial2Components[i];
            if ('status' in thisComponent) {
              thisComponent.status = psychoJS.NOT_STARTED;
            }
          }
          
          return psychoJS.NEXT;
        }
        
        function trial2RoutineEachFrame() {
          //------Loop for each frame of Routine 'trial2'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = trial2Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *word2* updates
          if (t >= 0.0 && word2.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            word2.tStart = t;  // (not accounting for frame time here)
            word2.frameNStart = frameN;  // exact frame index
            word2.setAutoDraw(true);
          }
          
          // *trial_number2* updates
          if (t >= 0.0 && trial_number2.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            trial_number2.tStart = t;  // (not accounting for frame time here)
            trial_number2.frameNStart = frameN;  // exact frame index
            trial_number2.setAutoDraw(true);
          }
          
          // *scale_msg2* updates
          if (t >= 2 && scale_msg2.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            scale_msg2.tStart = t;  // (not accounting for frame time here)
            scale_msg2.frameNStart = frameN;  // exact frame index
            scale_msg2.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return psychoJS.NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < trial2Components.length; ++i) {
            thisComponent = trial2Components[i];
            if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
            psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return psychoJS.FLIP_REPEAT;
          }
          else {
            return psychoJS.NEXT;
          }
        }
        
        function trial2RoutineEnd() {
          //------Ending Routine 'trial2'-------
          for (var i = 0; i < trial2Components.length; ++i) {
            thisComponent = trial2Components[i];
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // the Routine "trial2" was not non-slip safe, so reset the non-slip timer
          routineTimer.reset();
          return psychoJS.NEXT;
        }
        
        function trial1RoutineBegin() {
          //------Prepare to start Routine 'trial1'-------
          t = 0;
          trial1Clock.reset(); // clock
          frameN = -1;
          // update component parameters for each repeat
          word1.setText(word);
          trial_number1.setText(str(pract_trial.thisN+1) + " / " + str(pract_trial.nTotal) );
          // keep track of which components have finished
          trial1Components = [];
          trial1Components.push(word1);
          trial1Components.push(trial_number1);
          trial1Components.push(scale_msg1);
          for(var i = 0; i < trial1Components.length; ++i) {
            thisComponent = trial1Components[i];
            if ('status' in thisComponent) {
              thisComponent.status = psychoJS.NOT_STARTED;
            }
          }
          
          return psychoJS.NEXT;
        }
        
        function trial1RoutineEachFrame() {
          //------Loop for each frame of Routine 'trial1'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = trial1Clock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *word1* updates
          if (t >= 0.0 && word1.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            word1.tStart = t;  // (not accounting for frame time here)
            word1.frameNStart = frameN;  // exact frame index
            word1.setAutoDraw(true);
          }
          
          // *trial_number1* updates
          if (t >= 0 && trial_number1.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            trial_number1.tStart = t;  // (not accounting for frame time here)
            trial_number1.frameNStart = frameN;  // exact frame index
            trial_number1.setAutoDraw(true);
          }
          
          // *scale_msg1* updates
          if (t >= 2 && scale_msg1.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            scale_msg1.tStart = t;  // (not accounting for frame time here)
            scale_msg1.frameNStart = frameN;  // exact frame index
            scale_msg1.setAutoDraw(true);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return psychoJS.NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < trial1Components.length; ++i) {
            thisComponent = trial1Components[i];
            if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
            psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return psychoJS.FLIP_REPEAT;
          }
          else {
            return psychoJS.NEXT;
          }
        }
        
        function trial1RoutineEnd() {
          //------Ending Routine 'trial1'-------
          for (var i = 0; i < trial1Components.length; ++i) {
            thisComponent = trial1Components[i];
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // the Routine "trial1" was not non-slip safe, so reset the non-slip timer
          routineTimer.reset();
          return psychoJS.NEXT;
        }
        
        function the_endRoutineBegin() {
          //------Prepare to start Routine 'the_end'-------
          t = 0;
          the_endClock.reset(); // clock
          frameN = -1;
          routineTimer.add(2.000000);
          // update component parameters for each repeat
          // keep track of which components have finished
          the_endComponents = [];
          the_endComponents.push(text);
          for(var i = 0; i < the_endComponents.length; ++i) {
            thisComponent = the_endComponents[i];
            if ('status' in thisComponent) {
              thisComponent.status = psychoJS.NOT_STARTED;
            }
          }
          
          return psychoJS.NEXT;
        }
        
        function the_endRoutineEachFrame() {
          //------Loop for each frame of Routine 'the_end'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = the_endClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *text* updates
          if (t >= 0.0 && text.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            text.tStart = t;  // (not accounting for frame time here)
            text.frameNStart = frameN;  // exact frame index
            text.setAutoDraw(true);
          }
          frameRemains = 0.0 + 2 - frameDur * 0.75;  // most of one frame period left
          if (text.status === psychoJS.STARTED && t >= frameRemains) {
            text.setAutoDraw(false);
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return psychoJS.NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < the_endComponents.length; ++i) {
            thisComponent = the_endComponents[i];
            if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
            psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
          }
          
          // refresh the screen if continuing
          if (continueRoutine && routineTimer.getTime() > 0) {
            return psychoJS.FLIP_REPEAT;
          }
          else {
            return psychoJS.NEXT;
          }
        }
        
        function the_endRoutineEnd() {
          //------Ending Routine 'the_end'-------
          for (var i = 0; i < the_endComponents.length; ++i) {
            thisComponent = the_endComponents[i];
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          return psychoJS.NEXT;
        }
        
        function main_instructionRoutineBegin() {
          //------Prepare to start Routine 'main_instruction'-------
          t = 0;
          main_instructionClock.reset(); // clock
          frameN = -1;
          // update component parameters for each repeat
          key_resp_2 = new psychoJS.event.BuilderKeyResponse();
          // keep track of which components have finished
          main_instructionComponents = [];
          main_instructionComponents.push(instruction2);
          main_instructionComponents.push(key_resp_2);
          for(var i = 0; i < main_instructionComponents.length; ++i) {
            thisComponent = main_instructionComponents[i];
            if ('status' in thisComponent) {
              thisComponent.status = psychoJS.NOT_STARTED;
            }
          }
          
          return psychoJS.NEXT;
        }
        
        function main_instructionRoutineEachFrame() {
          //------Loop for each frame of Routine 'main_instruction'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = main_instructionClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *instruction2* updates
          if (t >= 0.0 && instruction2.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            instruction2.tStart = t;  // (not accounting for frame time here)
            instruction2.frameNStart = frameN;  // exact frame index
            instruction2.setAutoDraw(true);
          }
          
          // *key_resp_2* updates
          if (t >= 0.0 && key_resp_2.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_2.tStart = t;  // (not accounting for frame time here)
            key_resp_2.frameNStart = frameN;  // exact frame index
            key_resp_2.status = psychoJS.STARTED;
            // keyboard checking is just starting
            psychoJS.event.clearEvents({eventType:'keyboard'});
          }
          if (key_resp_2.status == psychoJS.STARTED) {
            theseKeys = psychoJS.event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              // a response ends the routine
              continueRoutine = false;
            }
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return psychoJS.NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < main_instructionComponents.length; ++i) {
            thisComponent = main_instructionComponents[i];
            if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
            psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return psychoJS.FLIP_REPEAT;
          }
          else {
            return psychoJS.NEXT;
          }
        }
        
        function main_instructionRoutineEnd() {
          //------Ending Routine 'main_instruction'-------
          for (var i = 0; i < main_instructionComponents.length; ++i) {
            thisComponent = main_instructionComponents[i];
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // the Routine "main_instruction" was not non-slip safe, so reset the non-slip timer
          routineTimer.reset();
          return psychoJS.NEXT;
        }
        
        function practice_introductionRoutineBegin() {
          //------Prepare to start Routine 'practice_introduction'-------
          t = 0;
          practice_introductionClock.reset(); // clock
          frameN = -1;
          // update component parameters for each repeat
          key_resp_1 = new psychoJS.event.BuilderKeyResponse();
          // keep track of which components have finished
          practice_introductionComponents = [];
          practice_introductionComponents.push(instruction1);
          practice_introductionComponents.push(key_resp_1);
          for(var i = 0; i < practice_introductionComponents.length; ++i) {
            thisComponent = practice_introductionComponents[i];
            if ('status' in thisComponent) {
              thisComponent.status = psychoJS.NOT_STARTED;
            }
          }
          
          return psychoJS.NEXT;
        }
        
        function practice_introductionRoutineEachFrame() {
          //------Loop for each frame of Routine 'practice_introduction'-------
          continueRoutine = true;
           // until we're told otherwise
          // get current time
          t = practice_introductionClock.getTime();
          frameN = frameN + 1;// number of completed frames (so 0 is the first frame)
          // update/draw components on each frame
          
          // *instruction1* updates
          if (t >= 0.0 && instruction1.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            instruction1.tStart = t;  // (not accounting for frame time here)
            instruction1.frameNStart = frameN;  // exact frame index
            instruction1.setAutoDraw(true);
          }
          
          // *key_resp_1* updates
          if (t >= 0.0 && key_resp_1.status === psychoJS.NOT_STARTED) {
            // keep track of start time/frame for later
            key_resp_1.tStart = t;  // (not accounting for frame time here)
            key_resp_1.frameNStart = frameN;  // exact frame index
            key_resp_1.status = psychoJS.STARTED;
            // keyboard checking is just starting
            psychoJS.event.clearEvents({eventType:'keyboard'});
          }
          if (key_resp_1.status == psychoJS.STARTED) {
            theseKeys = psychoJS.event.getKeys({keyList:['space']});
            
            // check for quit:
            if ("escape" in theseKeys) {
                endExpNow = true;
            }
            if (theseKeys.length > 0) {  // at least one key was pressed
              // a response ends the routine
              continueRoutine = false;
            }
          }
          
          // check if the Routine should terminate
          if (!continueRoutine) {  // a component has requested a forced-end of Routine
            return psychoJS.NEXT;
          }
          continueRoutine = false;// reverts to True if at least one component still running
          for(var i = 0; i < practice_introductionComponents.length; ++i) {
            thisComponent = practice_introductionComponents[i];
            if ('status' in thisComponent && thisComponent.status != psychoJS.FINISHED) {
              continueRoutine = true;
              break;
            }
          }
          // check for quit (the Esc key)
          if (endExpNow || psychoJS.event.getKeys({keyList:['escape']}).length > 0) {
            psychoJS.core.quit('The <Escape> key was pressed. Goodbye!');
          }
          
          // refresh the screen if continuing
          if (continueRoutine) {
            return psychoJS.FLIP_REPEAT;
          }
          else {
            return psychoJS.NEXT;
          }
        }
        
        function practice_introductionRoutineEnd() {
          //------Ending Routine 'practice_introduction'-------
          for (var i = 0; i < practice_introductionComponents.length; ++i) {
            thisComponent = practice_introductionComponents[i];
            if ("setAutoDraw" in thisComponent) {
              thisComponent.setAutoDraw(false);
            }
          }
          // the Routine "practice_introduction" was not non-slip safe, so reset the non-slip timer
          routineTimer.reset();
          return psychoJS.NEXT;
        }
        
        function registerResources() {
            psychoJS.resourceManager.scheduleRegistration(resourceScheduler);
        
            return psychoJS.NEXT;
        }
        
        function downloadResources() {
            psychoJS.resourceManager.scheduleDownload(resourceScheduler);
        
            return psychoJS.NEXT;
        }
        
        function pract_trialLoopBegin(thisScheduler) {
          // set up handler to look after randomisation of conditions etc
          try {
            pract_trial = new psychoJS.data.TrialHandler({nReps:1, method:'random',
              extraInfo:expInfo, originPath:undefined,
              trialList:psychoJS.data.importConditions('practice_stimuli.xlsx'),
              seed:undefined, name:'pract_trial'});
            thisExp.addLoop(pract_trial); // add the loop to the experiment
            thisPract_trial = pract_trial.trialList[pract_trial.trialSequence[0]]; // so we can initialise stimuli with some values
            // abbreviate parameter names if possible (e.g. rgb=thisPract_trial.rgb)
            abbrevNames(thisPract_trial);
            // Schedule each of the trials in the list to occur
            for (var i = 0; i < pract_trial.trialSequence.length; ++i) {
              thisPract_trial = pract_trial.trialList[pract_trial.trialSequence[i]];
              thisScheduler.add(abbrevNames(thisPract_trial));
              thisScheduler.add(trial1RoutineBegin);
              thisScheduler.add(trial1RoutineEachFrame);
              thisScheduler.add(trial1RoutineEnd);
              thisScheduler.add(recordLoopIteration(pract_trial));
            }
          } catch (exception) {
            console.log(exception);
          }
        
          return psychoJS.NEXT;
        }
        
        function pract_trialLoopEnd() {
          // get names of stimulus parameters
          if (psychoJS.isEmpty(pract_trial.trialList)) { // XXX equiv of : in ([], [None], None)
            params = [];
          }
          else {
            params = Object.keys(pract_trial.trialList[0]);
          }
        
          // save data for this loop
          thisExp.loopEnded(pract_trial);
          return psychoJS.NEXT;
          }
        
        function main_trialLoopBegin(thisScheduler) {
          // set up handler to look after randomisation of conditions etc
          try {
            main_trial = new psychoJS.data.TrialHandler({nReps:2, method:'random',
              extraInfo:expInfo, originPath:undefined,
              trialList:psychoJS.data.importConditions('main_stimuli.xlsx'),
              seed:undefined, name:'main_trial'});
            thisExp.addLoop(main_trial); // add the loop to the experiment
            thisMain_trial = main_trial.trialList[main_trial.trialSequence[0]]; // so we can initialise stimuli with some values
            // abbreviate parameter names if possible (e.g. rgb=thisMain_trial.rgb)
            abbrevNames(thisMain_trial);
            // Schedule each of the trials in the list to occur
            for (var i = 0; i < main_trial.trialSequence.length; ++i) {
              thisMain_trial = main_trial.trialList[main_trial.trialSequence[i]];
              thisScheduler.add(abbrevNames(thisMain_trial));
              thisScheduler.add(trial2RoutineBegin);
              thisScheduler.add(trial2RoutineEachFrame);
              thisScheduler.add(trial2RoutineEnd);
              thisScheduler.add(recordLoopIteration(main_trial));
            }
          } catch (exception) {
            console.log(exception);
          }
        
          return psychoJS.NEXT;
        }
        
        function main_trialLoopEnd() {
          // get names of stimulus parameters
          if (psychoJS.isEmpty(main_trial.trialList)) { // XXX equiv of : in ([], [None], None)
            params = [];
          }
          else {
            params = Object.keys(main_trial.trialList[0]);
          }
        
          // save data for this loop
          thisExp.loopEnded(main_trial);
          return psychoJS.NEXT;
          }
        
        function run() {
          // init psychoJS and set up OpenGL Canvas
          setupWin();
          psychoJS.init(win);
          
          // main scheduler
          scheduler = new psychoJS.Scheduler();
          
          // Store info about the experiment session
          expName = 'stroop';  // from the Builder filename that created this script
          expInfo = {'participant':'', 'session':'01'};
          
          // set up experiment
          scheduler.add(setupExperiment);
          scheduler.add(psychoJS.setupCallbacks);
          
          // register all available resources and download them
          resourceScheduler = new psychoJS.Scheduler();
          resourceScheduler.add(registerResources);
          resourceScheduler.add(downloadResources);
          // asynchronous approach: the resource scheduler is run in parallel to the main one
          scheduler.add(function() { resourceScheduler.start(win); });
          
          // dialog box
          scheduler.add(psychoJS.gui.DlgFromDict({dictionary:expInfo, title:expName}));
          
          flowScheduler = new psychoJS.Scheduler();
          dialogCancelScheduler = new psychoJS.Scheduler();
          scheduler.addConditionalBranches(function() { return psychoJS.gui.dialogComponent.button === 'OK'; }, flowScheduler, dialogCancelScheduler);
          
          // flowScheduler gets run if the participants presses OK
          flowScheduler.add(updateInfo); // add timeStamp
          flowScheduler.add(experimentInit);
          flowScheduler.add(practice_introductionRoutineBegin);
          flowScheduler.add(practice_introductionRoutineEachFrame);
          flowScheduler.add(practice_introductionRoutineEnd);
          pract_trialLoopScheduler = new psychoJS.Scheduler();
          flowScheduler.add(pract_trialLoopBegin, pract_trialLoopScheduler);
          flowScheduler.add(pract_trialLoopScheduler);
          flowScheduler.add(pract_trialLoopEnd);
          flowScheduler.add(main_instructionRoutineBegin);
          flowScheduler.add(main_instructionRoutineEachFrame);
          flowScheduler.add(main_instructionRoutineEnd);
          main_trialLoopScheduler = new psychoJS.Scheduler();
          flowScheduler.add(main_trialLoopBegin, main_trialLoopScheduler);
          flowScheduler.add(main_trialLoopScheduler);
          flowScheduler.add(main_trialLoopEnd);
          flowScheduler.add(the_endRoutineBegin);
          flowScheduler.add(the_endRoutineEachFrame);
          flowScheduler.add(the_endRoutineEnd);
          flowScheduler.add(quitPsychoJS);
          
          // quit if user presses Cancel in dialog box:
          dialogCancelScheduler.add(quitPsychoJS);
          
          scheduler.start(win);
        }
        
        function abbrevNames(thisTrial) {
          return function () {
            // abbreviate parameter names if possible (e.g. rgb = thisTrial.rgb)
            if (thisTrial != undefined) {
              for (paramName in thisTrial) {
                window[paramName] = thisTrial[paramName];
              }
            }
            return psychoJS.NEXT;
          };
        }
        
        function recordLoopIteration(currentLoop) {
          return function () {
            currentLoop.updateAttributesAtBegin();
            thisExp.nextEntry();
            return psychoJS.NEXT;
          }
        }
        
        function quitPsychoJS() {
            thisExp.save();
            win.close()
            psychoJS.core.quit();
            return psychoJS.QUIT;
        }

        run();
      });
    </script>

  </body>
</html>
